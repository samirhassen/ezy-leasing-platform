import { create } from 'zustand';
import { supabase } from '@/integrations/supabase/client';
import { Role, AuthSession, mockUsers } from '@/types/auth';

export type { Role } from '@/types/auth';

interface AuthState {
  session: AuthSession | null;
  loading: boolean;
  setSession: (session: AuthSession | null) => void;
  login: (email: string, password: string) => Promise<AuthSession>;
  signUp: (email: string, password: string, fullName: string) => Promise<AuthSession>;
  // loginUAEPass: () => Promise<AuthSession>; // Commented out for future use
  impersonate: (role: Role, demoCase?: string) => Promise<AuthSession>;
  bypass: (role: Role, demoCase?: string) => Promise<AuthSession>;
  logout: () => void;
}

export const useAuthStore = create<AuthState>((set, get) => ({
  session: import.meta.env.VITE_AUTH_DISABLED === 'true' ? {
    userId: 'dev-tenant-default',
    email: 'tenant@demo.local',
    name: 'Demo Tenant',
    role: 'TENANT',
    uaePassTier: '3',
    impersonated: true,
  } : null,
  loading: false,

  setSession: (session) => {
    set({ session, loading: false });
    
    // Skip Supabase persistence if auth is disabled
    if (import.meta.env.VITE_AUTH_DISABLED === 'true') {
      return;
    }
    
    // For impersonated sessions, use session storage
    if (session?.impersonated) {
      sessionStorage.setItem('auth_session', JSON.stringify(session));
      localStorage.removeItem('auth_session');
    } else {
      // For real auth sessions, let Supabase handle persistence
      localStorage.removeItem('auth_session');
      sessionStorage.removeItem('auth_session');
    }
  },

  login: async (email: string, password: string) => {
    try {
      console.log('[auth] Attempting Supabase login for:', email);
      
      // Try Supabase authentication first
      const { data, error } = await supabase.auth.signInWithPassword({
        email,
        password,
      });

      if (error) {
        // If Supabase auth fails in DEV, try mock fallback
        if (import.meta.env.DEV) {
          console.warn('[auth] Supabase login failed, trying DEV fallback:', error.message);
          const user = mockUsers.find(u => u.email === email && u.password === password);
          if (user) {
            console.log('[auth] DEV fallback successful for user:', user.email);
            const role = (user.profile.roles && user.profile.roles[0]) || 'TENANT';
            const session: AuthSession = {
              userId: `dev-${role.toLowerCase()}`,
              email: user.email,
              name: user.profile.name,
              role: role as Role,
              uaePassTier: user.profile.uaePassTier,
            };
            get().setSession(session);
            return session;
          }
        }
        throw new Error(error.message);
      }

      if (!data.user) {
        throw new Error('No user data returned');
      }

      // Get user profile to determine role
      const { data: profile, error: profileError } = await supabase
        .from('profiles')
        .select('*')
        .eq('user_id', data.user.id)
        .maybeSingle();

      if (profileError) {
        console.error('[auth] Profile fetch error:', profileError);
        throw new Error('Unable to fetch user profile');
      }

      if (!profile) {
        console.error('[auth] No profile found for user:', data.user.id);
        throw new Error('User profile not found. Please contact support.');
      }

      const session: AuthSession = {
        userId: data.user.id,
        email: data.user.email!,
        name: profile.full_name,
        role: (profile.roles[0] as Role) || 'TENANT',
        uaePassTier: (profile.uae_pass_tier as '2' | '3') || '3',
      };

      get().setSession(session);
      return session;
    } catch (e: any) {
      console.error('[auth] Login error:', e);
      throw e instanceof Error ? e : new Error('Login failed');
    }
  },

  signUp: async (email: string, password: string, fullName: string) => {
    try {
      console.log('[auth] Attempting Supabase signup for:', email);
      
      const redirectUrl = `${window.location.origin}/`;
      
      const { data, error } = await supabase.auth.signUp({
        email,
        password,
        options: {
          emailRedirectTo: redirectUrl,
          data: {
            full_name: fullName,
          }
        }
      });

      if (error) {
        throw new Error(error.message);
      }

      if (!data.user) {
        throw new Error('No user data returned');
      }

      // Profile will be created automatically by the database trigger
      // If user is confirmed (immediate in development), session will be set by auth state change
      if (data.user.email_confirmed_at) {
        const session: AuthSession = {
          userId: data.user.id,
          email: data.user.email!,
          name: fullName,
          role: 'TENANT',
          uaePassTier: '3',
        };
        get().setSession(session);
        return session;
      } else {
        // Email confirmation required
        throw new Error('Please check your email to confirm your account');
      }
    } catch (e: any) {
      console.error('[auth] Signup error:', e);
      throw e instanceof Error ? e : new Error('Signup failed');
    }
  },

  // UAE Pass login - commented out for future use
  // loginUAEPass: async () => {
  //   try {
  //     const startResponse = await fetch('/api/auth/uae-pass/mock/start', {
  //       method: 'POST',
  //       headers: { 'Content-Type': 'application/json' }
  //     });

  //     if (!startResponse.ok) {
  //       throw new Error('UAE Pass is temporarily unavailable');
  //     }

  //     const callbackResponse = await fetch('/api/auth/uae-pass/mock/callback', {
  //       method: 'POST',
  //       headers: { 'Content-Type': 'application/json' },
  //       body: JSON.stringify({ code: 'mock', state: 'mock' })
  //     });

  //     const responseText = await callbackResponse.text();

  //     if (callbackResponse.ok) {
  //       try {
  //         const data = JSON.parse(responseText);
  //         const { session } = data;
  //         get().setSession(session);
  //         return session;
  //       } catch (parseError) {
  //         if (import.meta.env.DEV && responseText.trim().startsWith('<')) {
  //           console.warn('[auth] UAE Pass API not available, using DEV fallback');
  //           const user = mockUsers.find(u => u.profile.roles.includes('TENANT')) || mockUsers[0];
  //           const devSession: AuthSession = {
  //             userId: 'dev-tenant',
  //             email: user.email,
  //             name: user.profile.name,
  //             role: 'TENANT',
  //             uaePassTier: '3',
  //           };
  //           get().setSession(devSession);
  //           return devSession;
  //         }
  //         throw new Error('Invalid response from server');
  //       }
  //     }

  //     throw new Error('UAE Pass authentication failed');
  //   } catch (e: any) {
  //     if (import.meta.env.DEV) {
  //       console.warn('[auth] UAE Pass network error, using DEV fallback:', e?.message);
  //       const user = mockUsers.find(u => u.profile.roles.includes('TENANT')) || mockUsers[0];
  //       const session: AuthSession = {
  //         userId: 'dev-tenant',
  //         email: user.email,
  //         name: user.profile.name,
  //         role: 'TENANT',
  //         uaePassTier: '3',
  //       };
  //       get().setSession(session);
  //       return session;
  //     }
  //     throw e instanceof Error ? e : new Error('UAE Pass authentication failed');
  //   }
  // },

  impersonate: async (role: Role, demoCase?: string) => {
    // Development-only impersonation that works with role switchers
    if (!import.meta.env.DEV) {
      throw new Error('Impersonation is only available in development');
    }

    const session: AuthSession = {
      userId: `dev-${role.toLowerCase()}`,
      email: `${role.toLowerCase()}@demo.local`,
      name: `${role} Demo`,
      role,
      uaePassTier: '3',
      impersonated: true,
    };
    
    get().setSession(session);
    return session;
  },

  bypass: async (role: Role, demoCase?: string) => {
    // Development-only bypass that works with role switchers
    if (!import.meta.env.DEV) {
      throw new Error('Bypass is only available in development');
    }

    const session: AuthSession = {
      userId: `u-${role.toLowerCase()}-1`,
      email: `${role.toLowerCase()}@demo.local`,
      name: `Demo ${role}`,
      role,
      uaePassTier: '3',
      impersonated: true,
    };
    
    get().setSession(session);
    return session;
  },

  logout: async () => {
    try {
      // Sign out from Supabase
      await supabase.auth.signOut();
    } catch (error) {
      console.error('[auth] Logout error:', error);
    }
    get().setSession(null);
  },
}));

// Initialize session from Supabase and storage
const initializeAuth = async () => {
  // Set up Supabase auth state listener
  supabase.auth.onAuthStateChange(async (event, supabaseSession) => {
    if (event === 'SIGNED_IN' && supabaseSession?.user) {
      // Get user profile for role information
      const { data: profile } = await supabase
        .from('profiles')
        .select('*')
        .eq('user_id', supabaseSession.user.id)
        .maybeSingle();

      if (profile) {
        const session: AuthSession = {
          userId: supabaseSession.user.id,
          email: supabaseSession.user.email!,
          name: profile.full_name,
          role: (profile.roles[0] as Role) || 'TENANT',
          uaePassTier: (profile.uae_pass_tier as '2' | '3') || '3',
        };
        useAuthStore.getState().setSession(session);
      }
    } else if (event === 'SIGNED_OUT') {
      // Check for impersonated session in sessionStorage
      const impersonatedSession = sessionStorage.getItem('auth_session');
      if (impersonatedSession) {
        try {
          const session = JSON.parse(impersonatedSession);
          if (session.impersonated) {
            useAuthStore.getState().setSession(session);
            return;
          }
        } catch (error) {
          console.error('Error parsing impersonated session:', error);
        }
      }
      useAuthStore.getState().setSession(null);
    }
  });

  // Check for existing Supabase session
  const { data: { session: supabaseSession } } = await supabase.auth.getSession();
  if (supabaseSession?.user) {
    // Trigger the auth state change listener
    return;
  }

  // Check for impersonated session in sessionStorage
  const impersonatedSession = sessionStorage.getItem('auth_session');
  if (impersonatedSession) {
    try {
      const session = JSON.parse(impersonatedSession);
      if (session.impersonated) {
        useAuthStore.getState().setSession(session);
      }
    } catch (error) {
      console.error('Error parsing impersonated session:', error);
    }
  }
};

// Initialize auth state on app start - but only if auth is enabled
if (import.meta.env.VITE_AUTH_DISABLED !== 'true') {
  initializeAuth();
} else {
  console.log('[auth] Auth disabled - using demo mode only');
}